/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/


// ************************************************************************* //
//                            avtQDFFileFormat.C                           //
// ************************************************************************* //

#include <avtQDFFileFormat.h>

#include <stdio.h>
#include <string>
#include <stdlib.h>

#include <vtkIntArray.h>
#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkLongArray.h>
#include <vtkUnsignedCharArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkPoints.h>
#include <vtkVertex.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

#include <hdf5.h>
#include <math.h>
#include <vector>

#include <DebugStream.h>

#include "SCell.h"
#include "QDFVisitUtils.h"
#include "QDFReaderUtils.h"

#define DUMMY_CHAR "_"
#define DENSITY_NAME "Density"
#define NUMBER_NAME "Number"

using     std::string;


// ****************************************************************************
//  Method: avtQDFFileFormat constructor
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************

avtQDFFileFormat::avtQDFFileFormat(const char *filename)
    : avtSTSDFileFormat(filename),
      m_hGridGroup(H5P_DEFAULT),
      m_hGeoGroup(H5P_DEFAULT),
      m_hClimateGroup(H5P_DEFAULT),
      m_hVegGroup(H5P_DEFAULT),
      m_hPopGroup(H5P_DEFAULT),
      m_sPopNames(NULL),
      m_fMinDistance(10000000)
{
    m_initialized = false;
    strcpy(m_sFileName, filename);
}

void 
avtQDFFileFormat::ActivateTimestep() {
    Initialize();
}

void
avtQDFFileFormat::Initialize() {
    if(!m_initialized) {
//        m_hFile = qdf_openFile(m_sFileName);
        m_hFile = H5Fopen(m_sFileName, H5F_ACC_RDONLY, H5P_DEFAULT);
        m_initialized = true;
    }
}



// ****************************************************************************
//  Method: avtQDFFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************

void
avtQDFFileFormat::FreeUpResources(void)
{
    /*
    if (m_hGridGroup >= 0) {
        qdf_closeGroup(m_hGridGroup);
        m_hGridGroup = H5P_DEFAULT;
    }

    if (m_hGeoGroup > 0) {
        qdf_closeGroup(m_hGeoGroup);
        m_hGeoGroup = H5P_DEFAULT;
     }

    if (m_hClimateGroup > 0) {
        qdf_closeGroup(m_hClimateGroup);
        m_hClimateGroup = H5P_DEFAULT;
    }

    if (m_hVegGroup > 0) {
        qdf_closeGroup(m_hVegGroup);
        m_hVegGroup = H5P_DEFAULT;
    }

    if (m_hPopGroup > 0) {

        for (std::map<std::string,hid_t>::iterator it = m_mapDataAgents.begin(); 
             it != m_mapDataAgents.end(); 
             it++) {
            qdf_closeDataSet(it->second);
        }

        m_mapNAgents.clear();
        m_mapDataAgents.clear();

        for (int i = 0; i < m_nPops; i++) {
            delete m_sPopNames[i];
        }
        delete[] m_sPopNames;

        qdf_closeGroup(m_hPopGroup);
        m_hPopGroup = H5P_DEFAULT;
    }

    if (m_hFile > 0) {
        H5Fclose(m_hFile);
        m_hFile = H5P_DEFAULT;
    }

    m_initialized = false;
    
    memset(m_sGridType, 0, 64);
    */
}


// ****************************************************************************
//  Method: avtQDFFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************

void
avtQDFFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    debug1 << "QDF: populating metadata from file " << m_sFileName << endl;
    
    Initialize();
 
    m_hGridGroup = qdf_openGroup(m_hFile, GRIDGROUP_NAME, true);
    
    if (m_hGridGroup < 0) {
        debug1 << "QDF: Group " << GRIDGROUP_NAME << " not found!!!" << endl;
    }

    if (m_hGridGroup >= 0) {
        int iRes = qdf_extractSAttribute(m_hGridGroup, "SURF_TYPE", 62, m_sGridType); // LTC, ICO, IEQ
        if (iRes != 0) {
            qdf_extractSAttribute(m_hGridGroup, "SURFTYPE", 62, m_sGridType); // because we like to change stuff at random
        }

        debug1 << "QDF: surface type: " << m_sGridType << endl;
        
        avtMeshMetaData *MeshMD = new avtMeshMetaData;
        
        MeshMD->name = GRIDGROUP_NAME;
        // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
        // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
        // MeshMD->meshType = AVT_UNSTRUCTURED_MESH;
        if (strcasecmp(m_sGridType, "LTC") == 0) {

            char* sLinks = new char[4];
            qdf_extractSAttribute(m_hGridGroup, "LINKS", 4, sLinks); 
            int iLinks = atoi(sLinks);
            delete[] sLinks;

            if (iLinks == 4) {
                debug1 << "QDF: metadata: rectangular mesh" << endl;
                MeshMD->meshType = AVT_RECTILINEAR_MESH;
            } else if (iLinks == 6) {
                debug1 << "QDF: metadata: hexagonal mesh" << endl;
                MeshMD->meshType = AVT_UNSTRUCTURED_MESH;
            }
            MeshMD->spatialDimension = 2;
        
        } else {
            //            MeshMD->meshType = AVT_UNSTRUCTURED_MESH; 
            debug1 << "QDF: metadata: icosahedral mesh" << endl;
            MeshMD->meshType = AVT_UNSTRUCTURED_MESH;
            MeshMD->spatialDimension = 3;
        }

        MeshMD->topologicalDimension = 2; 
        MeshMD->numBlocks = 1;

        md->Add(MeshMD);
    
        // the following may be possible 
        // more elegantly by reading first
        // the HDF5 metadata and
        // preparing an array of avtScalarMetaData?

        // GEOGRAPHY

        m_hGeoGroup = qdf_openGroup(m_hFile, GEOGROUP_NAME, true);
    
        if (m_hGeoGroup > 0) {
        
            if (H5Lexists(m_hGeoGroup, GEO_DS_LONGITUDE, H5P_DEFAULT)) {
                avtScalarMetaData *LongitudeMD = new avtScalarMetaData;
                LongitudeMD->name = GEO_DS_LONGITUDE;
                LongitudeMD->meshName = GRIDGROUP_NAME;
                LongitudeMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                LongitudeMD->hasUnits = true;
                LongitudeMD->units = "degrees";
                md->Add(LongitudeMD);
            }

            if (H5Lexists(m_hGeoGroup, GEO_DS_LATITUDE, H5P_DEFAULT)) {
                avtScalarMetaData *LatitudeMD = new avtScalarMetaData;
                LatitudeMD->name = GEO_DS_LATITUDE;
                LatitudeMD->meshName = GRIDGROUP_NAME;
                LatitudeMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                LatitudeMD->hasUnits = true;
                LatitudeMD->units = "degrees";
                md->Add(LatitudeMD);
            }

            if (H5Lexists(m_hGeoGroup, GEO_DS_ALTITUDE, H5P_DEFAULT)) {
                avtScalarMetaData *AltitudeMD = new avtScalarMetaData;
                AltitudeMD->name = GEO_DS_ALTITUDE;
                AltitudeMD->meshName = GRIDGROUP_NAME;
                AltitudeMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                AltitudeMD->hasUnits = true;
                AltitudeMD->units = "meters";
                md->Add(AltitudeMD);
            }

            if (H5Lexists(m_hGeoGroup, GEO_DS_AREA, H5P_DEFAULT)) {
                avtScalarMetaData *AreaMD = new avtScalarMetaData;
                AreaMD->name = GEO_DS_AREA;
                AreaMD->meshName = GRIDGROUP_NAME;
                AreaMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                AreaMD->hasUnits = true;
                AreaMD->units = "Earth radii squared";
                md->Add(AreaMD);
            }

            if (H5Lexists(m_hGeoGroup, GEO_DS_WATER, H5P_DEFAULT)) {
                avtScalarMetaData *WaterMD = new avtScalarMetaData;
                WaterMD->name = GEO_DS_WATER;
                WaterMD->meshName = GRIDGROUP_NAME;
                WaterMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                WaterMD->hasUnits = true;
                WaterMD->units = "";
                md->Add(WaterMD);
            }

            if (H5Lexists(m_hGeoGroup, GEO_DS_ICE_COVER, H5P_DEFAULT)) {
                avtScalarMetaData *IceMD = new avtScalarMetaData;
                IceMD->name = GEO_DS_ICE_COVER;
                IceMD->meshName = GRIDGROUP_NAME;
                IceMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                IceMD->hasUnits = false;
                md->Add(IceMD);
            }
        
        } else {
            // WE DON'T HAVE GEOGRAPHY
        }


        // CLIMATE

        m_hClimateGroup = qdf_openGroup(m_hFile, CLIGROUP_NAME, true);

        if (m_hClimateGroup > 0) {
        
            if (H5Lexists(m_hClimateGroup, CLI_DS_ACTUAL_TEMPS, H5P_DEFAULT)) {
                avtScalarMetaData *ActTempMD = new avtScalarMetaData;
                ActTempMD->name = CLI_DS_ACTUAL_TEMPS;
                ActTempMD->meshName = GRIDGROUP_NAME;
                ActTempMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                ActTempMD->hasUnits = true;
                ActTempMD->units = "Celsius";
                md->Add(ActTempMD);
            }
        
            if (H5Lexists(m_hClimateGroup, CLI_DS_ACTUAL_RAINS, H5P_DEFAULT)) {
                avtScalarMetaData *ActRainMD = new avtScalarMetaData;
                ActRainMD->name = CLI_DS_ACTUAL_RAINS;
                ActRainMD->meshName = GRIDGROUP_NAME;
                ActRainMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                ActRainMD->hasUnits = true;
                ActRainMD->units = "";
                md->Add(ActRainMD);
            }
        
            if (H5Lexists(m_hClimateGroup, CLI_DS_ANN_MEAN_TEMP, H5P_DEFAULT)) {
                avtScalarMetaData *AnnMeanTempMD = new avtScalarMetaData;
                AnnMeanTempMD->name = CLI_DS_ANN_MEAN_TEMP;
                AnnMeanTempMD->meshName = GRIDGROUP_NAME;
                AnnMeanTempMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                AnnMeanTempMD->hasUnits = true;
                AnnMeanTempMD->units = "Celsius";
                md->Add(AnnMeanTempMD);
            }
        
            if (H5Lexists(m_hClimateGroup, CLI_DS_ANN_TOT_RAIN, H5P_DEFAULT)) {
                avtScalarMetaData *AnnTotRainMD = new avtScalarMetaData;
                AnnTotRainMD->name = CLI_DS_ANN_TOT_RAIN;
                AnnTotRainMD->meshName = GRIDGROUP_NAME;
                AnnTotRainMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                AnnTotRainMD->hasUnits = true;
                AnnTotRainMD->units = "";
                md->Add(AnnTotRainMD);
            }

            // seasonal data is a bit tougher, maybe do it later

        } else {
            // WE DON'T HAVE CLIMATE
        }


        // VEGETATION
      
        m_hVegGroup = qdf_openGroup(m_hFile, VEGGROUP_NAME, true);
        if (m_hVegGroup > 0) {

            qdf_extractAttribute(m_hVegGroup, VEG_ATTR_NUM_SPECIES, 1, &m_nVegSpecies);
            
            for (int i = 0; i < m_nVegSpecies; i++) {
            
                char *name1 = new char[128];
                sprintf(name1, "%s%s%d", VEG_DS_MASS, DUMMY_CHAR, i);

                if (H5Lexists(m_hVegGroup, name1, H5P_DEFAULT)) {
                    avtScalarMetaData *VegMassMD = new avtScalarMetaData;
                    VegMassMD->name = name1;
                    VegMassMD->meshName = GRIDGROUP_NAME;
                    VegMassMD->centering = AVT_NODECENT;
                    VegMassMD->hasUnits = true;
                    VegMassMD->units = "unknown";
                    md->Add(VegMassMD);
                }

                char *name2 = new char[128];
                sprintf(name2, "%s%s%d", VEG_DS_NPP, DUMMY_CHAR, i);

                if (H5Lexists(m_hVegGroup, name2, H5P_DEFAULT)) {
                    avtScalarMetaData *VegANPPMD = new avtScalarMetaData;
                    VegANPPMD->name = name2;
                    VegANPPMD->meshName = GRIDGROUP_NAME;
                    VegANPPMD->centering = AVT_NODECENT;
                    VegANPPMD->hasUnits = true;
                    VegANPPMD->units = "unknown";
                    md->Add(VegANPPMD);
                }
            }            
        } else {
            // WE DON'T HAVE VEGETATION
        }
        

        // MOVE STATISTICS
        
        if (H5Lexists(m_hFile, MSTATGROUP_NAME, H5P_DEFAULT)) {
            m_hMoveStatGroup = qdf_openGroup(m_hFile, MSTATGROUP_NAME, false);

            if (m_hMoveStatGroup > 0) {


                if (H5Lexists(m_hMoveStatGroup, MSTAT_DS_DIST, H5P_DEFAULT)) {
                    avtScalarMetaData *DistMD = new avtScalarMetaData;
                    DistMD->name = "TravelledDist";
                    DistMD->meshName = GRIDGROUP_NAME;
                    DistMD->centering = AVT_NODECENT;
                    DistMD->hasUnits = true;
                    DistMD->units = "unknown";
                    md->Add(DistMD);
                }
                
                if (H5Lexists(m_hMoveStatGroup, MSTAT_DS_HOPS, H5P_DEFAULT)) {
                    avtScalarMetaData *HopsMD = new avtScalarMetaData;
                    HopsMD->name = "Hops";
                    HopsMD->meshName = GRIDGROUP_NAME;
                    HopsMD->centering = AVT_NODECENT;
                    HopsMD->hasUnits = true;
                    HopsMD->units = "unknown";
                    md->Add(HopsMD);
                }
                
                if (H5Lexists(m_hMoveStatGroup, MSTAT_DS_TIME, H5P_DEFAULT)) {
                    avtScalarMetaData *ArrivalMD = new avtScalarMetaData;
                    ArrivalMD->name = "Arrival";
                    ArrivalMD->meshName = GRIDGROUP_NAME;
                    ArrivalMD->centering = AVT_NODECENT;
                    ArrivalMD->hasUnits = true;
                    ArrivalMD->units = "unknown";
                    md->Add(ArrivalMD);
                }

                if (H5Lexists(m_hMoveStatGroup, "LocalSpeed", H5P_DEFAULT)) {
                    avtScalarMetaData *LocalSpeedMD = new avtScalarMetaData;
                    LocalSpeedMD->name = "LocalSpeed";
                    LocalSpeedMD->meshName = GRIDGROUP_NAME;
                    LocalSpeedMD->centering = AVT_NODECENT;
                    LocalSpeedMD->hasUnits = true;
                    LocalSpeedMD->units = "unknown";
                    md->Add(LocalSpeedMD);
                }
            } else {
                // shouldn't happen
            }
        } else {
            // we don't have move stats
        }
        


        
        // POPULATIONS
        
        // here expose populations metadata
        // some of which will belong to the Pops point meshes
        // and some, e.g. density, will belong to the Grid mesh (GRIDGROUP_NAME)
        
        m_hPopGroup = qdf_openGroup(m_hFile, POPGROUP_NAME, true);
        
        if (m_hPopGroup > 0) {
            
            debug1 << "QDF: getting pop info... " << endl;

            int iResult = H5Gget_info(m_hPopGroup, &m_infoPopGroup);
            
            if (iResult >= 0) {
                m_nPops = m_infoPopGroup.nlinks;
                debug1 << "QDF: Creating metadata for " << m_nPops << " populations" << endl;
                
                m_sPopNames = new char*[m_nPops];

                for (int i = 0; i < m_nPops; i++) {
                    m_sPopNames[i] = new char[64];
                    H5Gget_objname_by_idx(m_hPopGroup, i, m_sPopNames[i], 64);
                    
                    debug1 << "QDF: Pop #" << i << ": " << m_sPopNames[i] << endl;
                    
                    hid_t hThisPop = qdf_openGroup(m_hPopGroup, m_sPopNames[i], true);


                    // create point mesh for population agents

                    avtMeshMetaData *PopMeshMD = new avtMeshMetaData;
        
                    PopMeshMD->name = m_sPopNames[i];
                    PopMeshMD->meshType = AVT_POINT_MESH;
                    PopMeshMD->spatialDimension = (!strcasecmp(m_sGridType,"LTC")) ? 2 : 3;
                    PopMeshMD->topologicalDimension = 0; 
                    PopMeshMD->numBlocks = 1;
                    md->Add(PopMeshMD);
                    
                    debug1 << "QDF: added point mesh for pop " << m_sPopNames[i] << endl;


                    // add scalar for agent density by default to Grid mesh
                    
                    char *sPopDens = new char[128];
                    strcpy(sPopDens, m_sPopNames[i]);
                    strcat(sPopDens, DUMMY_CHAR);
                    strcat(sPopDens, NUMBER_NAME);
                    avtScalarMetaData *PopDensMD = new avtScalarMetaData;
                    PopDensMD->name = sPopDens;
                    PopDensMD->meshName = GRIDGROUP_NAME;
                    PopDensMD->centering = AVT_NODECENT;
                    PopDensMD->hasUnits = false;
                    PopDensMD->units = "";
                    md->Add(PopDensMD);
                    

                    // now, let's populate the pop metadata...
                    
                    hid_t hThisDataset = H5Dopen(hThisPop, AGENT_DATASET_NAME, H5P_DEFAULT);
                    hid_t hAgentType = H5Dget_type(hThisDataset);     // get the agent compound data type
                    size_t iAgentTypeSize = H5Tget_size(hAgentType);  // get its size in bytes for later use
                    int nFields = H5Tget_nmembers(hAgentType);        // how many data fiels are in the compound agent type?
                    hssize_t nAgents = H5Dget_storage_size(hThisDataset)/iAgentTypeSize; // how many agents?

                    // save valuable information for later use
                    m_mapDataAgents.insert(std::pair<const char*,hid_t>(m_sPopNames[i], hThisDataset));
                    m_mapNAgents.insert(std::pair<const char*, int>(m_sPopNames[i], (int)nAgents));
                    
                    debug1 << "QDF: Pop " << m_sPopNames[i] << " has " << nFields << " fields and " << nAgents << " agents" << endl;

                    for (unsigned int j = 0; j < nFields; j++) {
                        char* sFieldName = new char[63];
                        sFieldName = H5Tget_member_name(hAgentType, j);  // get the name of each field
                        int iFieldOffset = H5Tget_member_offset(hAgentType, j);   // get its offset for later use
                        hid_t tFieldType = H5Tget_member_type(hAgentType, j);
                        hid_t tFieldTypeSize = H5Tget_size(tFieldType);

                        // create datatype for this data field, we need it to read the data
                        // without having to fill in a whole agent array with everything
                        hid_t tReadType = H5Tcreate(H5T_COMPOUND, tFieldTypeSize);
                        H5Tinsert(tReadType, sFieldName, 0, tFieldType);

                        char* sUniqueFieldName = new char[128];
                        strcpy(sUniqueFieldName, m_sPopNames[i]);
                        strcat(sUniqueFieldName, DUMMY_CHAR);
                        strcat(sUniqueFieldName, sFieldName);  // name = POPNAME:FIELDNAME to avoid duplication between pops

                        debug1 << "QDF: adding metadata for " << sUniqueFieldName << endl;

                        std::pair<hid_t,hid_t> pairDatasetAndType = std::pair<hid_t,hid_t>(hThisDataset, tReadType);
                        m_mapAgentFields.insert(std::pair< const char*,std::pair<hid_t,hid_t> >
                                                (sUniqueFieldName, pairDatasetAndType));
                        
                        avtScalarMetaData *ThisFieldMD = new avtScalarMetaData;
                        ThisFieldMD->name = sUniqueFieldName;
                        ThisFieldMD->meshName = m_sPopNames[i];
                        ThisFieldMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                        ThisFieldMD->hasUnits = false;
                        md->Add(ThisFieldMD);
                      
                        debug1 << "QDF: added metadata" << endl;
  
                        delete sFieldName;
                    }

                }
            }
        } else {
            // WE DON'T HAVE POPULATIONS
        }
        
    } // end if (m_hGridGroup > 0)

    // should I delete the metadata here?

}


// ****************************************************************************
//  Method: avtQDFFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************


vtkDataSet *
avtQDFFileFormat::GetMesh(const char *meshname)
{

    if (strcasecmp(GRIDGROUP_NAME, meshname) == 0) {

        debug1 << "QDF: GetMesh() for file " << m_sFileName << endl;

        // we create a grid mesh

        vtkDataSet* Grid = NULL;

        if (strcasecmp(m_sGridType, "LTC") == 0) {

            char* sLinks = new char[4];
            qdf_extractSAttribute(m_hGridGroup, "LINKS", 4, sLinks); 
            int iLinks = atoi(sLinks);
            delete[] sLinks;

            if (iLinks == 4) {
                Grid = GetRectMesh();
            } else if (iLinks == 6) {
                Grid = GetHexMesh();
            }

        } else if (strcasecmp(m_sGridType, "ICO") == 0 || 
                   strcasecmp(m_sGridType, "IEQ") == 0) {

            if (m_hGeoGroup > 0) {
                Grid = GetIcoEqMesh(); 
            } 
        }    
        return Grid;

    } else {
        
        if (m_mapNAgents.find(meshname) != m_mapNAgents.end()) {
            vtkDataSet *AgentMesh = NULL;
            if (strcasecmp(m_sGridType, "LTC") == 0) {
                AgentMesh = GetAgentFlatMesh(meshname);
            } else {
                AgentMesh = GetAgentIcoEqMesh(meshname);
            }
            return AgentMesh;
        } else {
            debug1 << "QDF: CANNOT CREATE MESH " << meshname << endl;
        }
    }
}


/**************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetAgentFlatMesh(const char *popname) {
    
    // for agent positions, we need to know spatial coordinates of grid nodes

    debug1 << "QDF: called GetAgentFlatMesh" << endl;

    vtkDataSet *BaseGrid = GetMesh(GRIDGROUP_NAME);
    vtkIdType nNodes = BaseGrid->GetNumberOfPoints();

    debug1 << "QDF: confirm that there are " << nNodes << " nodes" << endl;

    double *adNodes = (double*)malloc(nNodes * 3 * sizeof(double));
    for (vtkIdType i = 0; i < nNodes; i++) {
        BaseGrid->GetPoint(i, adNodes + 3 * i);
    }
    
    debug1 << "QDF: got coordinates from " << GRIDGROUP_NAME << " for " << nNodes << " nodes" << endl;

    int nAgents = (m_mapNAgents.find(popname))->second;

    debug1 << "QDF: processing data for " << nAgents << " agents" << endl;

    float *xarray = new float[nAgents];
    float *yarray = new float[nAgents];
    
    // let's read the agents' locations (cell IDs)

    char* sCellIDName = new char[128];
    strcpy(sCellIDName, popname);
    strcat(sCellIDName, DUMMY_CHAR);
    strcat(sCellIDName, GRID_DS_CELL_ID);
    hid_t hPopData = ((m_mapAgentFields.find(sCellIDName))->second).first;
    hid_t hCellIDType = ((m_mapAgentFields.find(sCellIDName))->second).second;
    
    debug1 << "QDF: GetAgentFlatMesh preparing to read " << sCellIDName << endl;

    delete sCellIDName;

    int *aiAgentCells = new int[nAgents];

    herr_t iErr = H5Dread(hPopData, hCellIDType, H5S_ALL, H5S_ALL, H5P_DEFAULT, aiAgentCells);
    
    srand(time(NULL));
    for (int i = 0; i < nAgents; i++) {
        int iCell = aiAgentCells[i];
        xarray[i] = (adNodes + 3 * iCell)[0] + 0.25 * m_fMinDistance * GeoDeviation();
        yarray[i] = (adNodes + 3 * iCell)[1] + 0.25 * m_fMinDistance * GeoDeviation();
    }
    
    debug1 << "QDF: coords created" << endl;

    
    // now let's create the vtk points for the point mesh
    
    vtkPoints *Points = vtkPoints::New();
    Points->SetNumberOfPoints(nAgents);
    float *pts = (float *)Points->GetVoidPointer(0);
    float *xc = xarray;
    float *yc = yarray;
    float zOffset = (!strcasecmp(m_sGridType,"LTC")) ? 0 : 0.1 * m_fMinDistance;

    for (int i = 0; i < nAgents; i++) {
        *pts++ = *xc++;
        *pts++ = *yc++;
        *pts++ = zOffset;
    }
    
    delete aiAgentCells;
    delete xarray;
    delete yarray;

    vtkUnstructuredGrid *AgentMesh = vtkUnstructuredGrid::New();
    AgentMesh->SetPoints(Points);
    Points->Delete();
    AgentMesh->Allocate(nAgents);
    vtkIdType onevertex;
    for (int i = 0; i < nAgents; i++) {
        onevertex = i;
        AgentMesh->InsertNextCell(VTK_VERTEX, 1, &onevertex);
    }

    return AgentMesh;
}

/**************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetAgentIcoEqMesh(const char *popname) {
    
    // for agent positions, we need to know spatial coordinates of grid nodes

    debug1 << "QDF: called GetAgentIcoEqMesh" << endl;

    double dRadius = 1.0;
    qdf_extractAttribute(m_hGeoGroup, GEO_ATTR_RADIUS, 1, &dRadius);

    GetMesh(GRIDGROUP_NAME);  // still need to call? to compute m_fMinDistance?

    dRadius = dRadius * (1 + 0.1 * m_fMinDistance);  // lift the agents over the Earth's surface for visibility

    int nnodes = 0;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    double *Lat = new double[nnodes];
    double *Lon = new double[nnodes];
    qdf_readArray(m_hGeoGroup, GEO_DS_LATITUDE, nnodes, Lat);
    qdf_readArray(m_hGeoGroup, GEO_DS_LONGITUDE, nnodes, Lon);

    // correct Lat and Lon for singularities
    Lat[0] = 89.99999;
    Lat[11] = -89.99999;
    for (int i = 0; i < nnodes; i++) {
        Lon[i] = Lon[i] - 0.00001;
    }
    

    // let's read the agents' locations (cell IDs)

    int nAgents = (m_mapNAgents.find(popname))->second;
    char* sCellIDName = new char[128];
    strcpy(sCellIDName, popname);
    strcat(sCellIDName, DUMMY_CHAR);
    strcat(sCellIDName, GRID_DS_CELL_ID);
    hid_t hPopData = ((m_mapAgentFields.find(sCellIDName))->second).first;
    hid_t hCellIDType = ((m_mapAgentFields.find(sCellIDName))->second).second;
    
    debug1 << "QDF: GetAgentIcoEqMesh preparing to read " << sCellIDName << endl;

    int *aiAgentCells = new int[nAgents];

    herr_t iErr = H5Dread(hPopData, hCellIDType, H5S_ALL, H5S_ALL, H5P_DEFAULT, aiAgentCells);

    float* xarray = new float[nAgents];
    float* yarray = new float[nAgents];
    float* zarray = new float[nAgents];
    
    double PI = 3.14159;
    
    // set spherical coordinates of agents
    // with tiny deviations on the tangent plane
    srand(time(NULL));
    for (int i = 0; i < nAgents; i++) {
        int iCell = aiAgentCells[i];
        float dlo = Lon[iCell] * PI / 180. + 0.25 * m_fMinDistance * GeoDeviation() / cos(Lat[iCell] * PI / 180.);
        float dla = Lat[iCell] * PI / 180. + 0.25 * m_fMinDistance * GeoDeviation();
        xarray[i] = dRadius * cos(dla) * cos(dlo);
        yarray[i] = dRadius * cos(dla) * sin(dlo);
        zarray[i] = dRadius * sin(dla);
    }
    
    
    delete Lon;
    delete Lat;

    // now let's create the vtk points for the point mesh
    
    vtkPoints *Points = vtkPoints::New();
    Points->SetNumberOfPoints(nAgents);
    float *pts = (float *)Points->GetVoidPointer(0);
    float *xc = xarray;
    float *yc = yarray;
    float *zc = zarray;

    for (int i = 0; i < nAgents; i++) {
        *pts++ = *xc++;
        *pts++ = *yc++;
        *pts++ = *zc++;
    }
    
    delete aiAgentCells;
    delete xarray;
    delete yarray;
    delete zarray;

    vtkUnstructuredGrid *AgentMesh = vtkUnstructuredGrid::New();
    AgentMesh->SetPoints(Points);
    Points->Delete();
    AgentMesh->Allocate(nAgents);
    vtkIdType onevertex;
    for (int i = 0; i < nAgents; i++) {
        onevertex = i;
        AgentMesh->InsertNextCell(VTK_VERTEX, 1, &onevertex);
    }

    return AgentMesh;
}


/**************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetRectMesh() {
    
    int dims[3] = {1, 1, 1};

    int nnodes = 0;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    char* sW = new char[16];
    qdf_extractSAttribute(m_hGridGroup, "W", 16, sW);
    dims[0] = atoi(sW);
    delete[] sW;

    char* sH = new char[16];
    qdf_extractSAttribute(m_hGridGroup, "H", 16, sH);
    dims[1] = atoi(sH);
    delete[] sH;
    

    float* xarray = new float[nnodes];
    float* yarray = new float[nnodes];
    float* zarray = 0;

    char* sProjG = new char[128];
    int iResult = qdf_extractSAttribute(m_hGridGroup, "PROJG", 128, sProjG);
    if ( iResult == 0) {
        float* fAtt = new float[7];
        char *sAtt = strtok(sProjG, " ");
        fAtt[0] = atof(sAtt);
        for (int i=1; i<7; i++) {
            char *sAtt = strtok(NULL, " ");  // continue scanning...
            fAtt[i] = atof(sAtt);
        }

        float fXLength = fAtt[2];
        float fYLength = fAtt[3];
        float fXCenter = fAtt[4];
        float fYCenter = fAtt[5];
        float fDeltaX  = fXLength / dims[0];
        float fDeltaY  = fYLength / dims[1];

        m_fMinDistance = (fDeltaX < fDeltaY) ? fDeltaX : fDeltaY;

        int i = 0;
        for (int y = 0; y < dims[1]; y++) {
            for (int x = 0; x < dims[0]; x++) {
                xarray[i] = x * fDeltaX + fXCenter;
                yarray[i] = y * fDeltaY + fYCenter;
                i++;
            }
        }

    } else {
    
        debug1 << "QDF: reading lon and lat" << endl;

        double* Lat = new double[nnodes];
        double* Lon = new double[nnodes];
        
        qdf_readArray(m_hGeoGroup, GEO_DS_LATITUDE, nnodes, Lat);
        qdf_readArray(m_hGeoGroup, GEO_DS_LONGITUDE, nnodes, Lon);
        
        for (int i = 0; i < nnodes; i++) {
            xarray[i] = Lon[i];
            yarray[i] = Lat[i];
        }

        m_fMinDistance = fabs(Lon[1] - Lon[0]);

        delete[] Lat;
        delete[] Lon;
    }
    
    delete [] sProjG;


    vtkPoints* Points = vtkPoints::New();
    Points->SetNumberOfPoints(nnodes);
    
    float *pts = (float *)Points->GetVoidPointer(0);
    float *xc = xarray;
    float *yc = yarray;
    for (int y = 0; y < dims[1]; y++) {
        for (int x = 0; x < dims[0]; x++) {
            *pts++ = *xc++;
            *pts++ = *yc++;
            *pts++ = 0.;
        }
    }
    
    vtkStructuredGrid* Grid = vtkStructuredGrid::New();
    Grid->SetPoints(Points);
    Grid->SetDimensions(dims);
    Points->Delete();

    delete[] xarray;
    delete[] yarray;
    
    return Grid;
}

/*********************************************************************/

vtkDataSet *
avtQDFFileFormat::GetHexMesh() {
    
    float hratio = 0.8660254; // sqrt(3)/2
    float offsetfactor = 0.5; 

    int dims[3] = {1, 1, 1};

    int nnodes = 0;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    char* sW = new char[16];
    qdf_extractSAttribute(m_hGridGroup, "W", 16, sW);
    dims[0] = atoi(sW);
    delete[] sW;

    char* sH = new char[16];
    qdf_extractSAttribute(m_hGridGroup, "H", 16, sH);
    dims[1] = atoi(sH);
    delete[] sH;
    
    float* xarray = new float[nnodes];
    float* yarray = new float[nnodes];
    float* zarray = 0;

    char* sProjG = new char[128];
    int iResult = qdf_extractSAttribute(m_hGridGroup, "PROJG", 128, sProjG);
    if (iResult == 0) {
        float* fAtt = new float[7];
        char *sAtt = strtok(sProjG, " ");
        fAtt[0] = atof(sAtt);
        for (int i=1; i<7; i++) {
            char *sAtt = strtok(NULL, " ");  // continue scanning...
            fAtt[i] = atof(sAtt);
        }

        // FILL IN NODE COORDINATES

        float fXLength = fAtt[2];
        float fYLength = fAtt[3];
        float fXCenter = fAtt[4];
        float fYCenter = fAtt[5];
        float fDeltaX  = fXLength / dims[0];
        float fDeltaY  = /*hratio **/ fYLength / dims[1];
        float fOddRowOffset = offsetfactor * fDeltaX;

        m_fMinDistance = (fDeltaX < fDeltaY) ? fDeltaX : fDeltaY;

        int i = 0;
        for (int y = 0; y < dims[1]; y++) {
            for (int x = 0; x < dims[0]; x++) {
                xarray[i] = x * fDeltaX + fXCenter + (y % 2) * fOddRowOffset;
                yarray[i] = y * fDeltaY + fYCenter;
                i++;
            }
        }

    } else {

        double* Lat = new double[nnodes];
        double* Lon = new double[nnodes];
        
        qdf_readArray(m_hGeoGroup, GEO_DS_LATITUDE, nnodes, Lat);
        qdf_readArray(m_hGeoGroup, GEO_DS_LONGITUDE, nnodes, Lon);

        for (int i = 0; i < nnodes; i++) {
            xarray[i] = Lon[i];
            yarray[i] = Lat[i];
        }

        m_fMinDistance = hratio * fabs(Lon[1] - Lon[0]);

        delete[] Lat;
        delete[] Lon;
    }

    delete [] sProjG;


    // CREATE VTK POINTS
   
    vtkPoints* Points = vtkPoints::New();
    Points->SetNumberOfPoints(nnodes);

    float *pts = (float *)Points->GetVoidPointer(0);
    float *xc = xarray;
    float *yc = yarray;
    for (int y = 0; y < dims[1]; y++) {
        for (int x = 0; x < dims[0]; x++) {
            *pts++ = *xc++;
            *pts++ = *yc++;
            *pts++ = 0.;
        }
    }
    
    delete[] xarray;
    delete[] yarray;


    // FILL IN CONNECTIVITY
    
    // there are 1 fewer rows of triangles than of nodes
    // and there are 2 * (n - 1) triangles per row, 
    // where n is the nodes in a row

    int ntriangles = (dims[1] - 1) * 2 * (dims[0] - 1); 

    int *connectivity = new int[ntriangles * 3]; 

    // order of vertices for VTK_TRIANGLE IS COUNTERCLOCKWISE
    // (surface normal points towards you)

    int j = 0;
    int iY = 0;
    while (iY < dims[1] - 1) {
        if ( (iY % 2) == 0) {
            for (int iX = 1; iX < dims[0]; iX++) {

                connectivity[j++] = iX + iY * dims[0] - 1;
                connectivity[j++] = iX + iY * dims[0];
                connectivity[j++] = iX + (iY + 1) * dims[0] - 1;

                connectivity[j++] = iX + iY * dims[0];
                connectivity[j++] = iX + (iY + 1) * dims[0];
                connectivity[j++] = iX + (iY + 1) * dims[0] - 1;
            }
        } else {
            for (int iX = 0; iX < dims[0] - 1; iX++) {

                connectivity[j++] = iX + iY * dims[0];
                connectivity[j++] = iX + iY * dims[0] + 1;
                connectivity[j++] = iX + (iY + 1) * dims[0] + 1;

                connectivity[j++] = iX + iY * dims[0];
                connectivity[j++] = iX + (iY + 1) * dims[0] + 1;
                connectivity[j++] = iX + (iY + 1) * dims[0];
            }
        }
        iY++;
    }
 
    // Create the vtk grid object

    vtkUnstructuredGrid *Grid = vtkUnstructuredGrid::New();
    Grid->SetPoints(Points);
    Points->Delete();
    Grid->Allocate(ntriangles);

    int nverts = 3;
    vtkIdType verts[nverts];
    int *conn = connectivity;

    for (int i = 0; i < ntriangles; i++) {
        for(int j = 0; j < nverts; j++) {
            verts[j] = conn[j];
        }
        conn += nverts;
        Grid->InsertNextCell(VTK_TRIANGLE, nverts, verts);
    }

    delete[] connectivity;
    
    return Grid;
}

/************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetIcoEqMesh() {
    
    debug1 << "QDF: GetIcoEqMesh" << endl;

    int nnodes = 0;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    debug1 << "QDF: " << nnodes << " nodes" << endl;

    double dRadius = 1.0;
    qdf_extractAttribute(m_hGeoGroup, GEO_ATTR_RADIUS, 1, &dRadius);
    
    double* Lat = new double[nnodes];
    double* Lon = new double[nnodes];

    qdf_readArray(m_hGeoGroup, GEO_DS_LATITUDE, nnodes, Lat);
    qdf_readArray(m_hGeoGroup, GEO_DS_LONGITUDE, nnodes, Lon);

    // correct Lat and Lon for singularities
    for (int i = 0; i < nnodes; i++) {
        if (fabs(Lat[i] - 90) < 1e-6) {
            Lat[i] = 89.99999;
        } else if (fabs(Lat[i] + 90) < 1e-6) {
            Lat[i] = -89.99999;
        }
        Lon[i] = Lon[i] - 0.00001;
    }
    
    debug1 << "QDF: Lon and Lat are ready" << endl;

    float* xarray = new float[nnodes];
    float* yarray = new float[nnodes];
    float* zarray = new float[nnodes];
    
    double PI = 3.14159;

    // set spherical coordinates of nodes

    for (int i = 0; i < nnodes; i++) {
        xarray[i] = dRadius * cos(Lat[i] * PI / 180.) * cos(Lon[i] * PI / 180.);
        yarray[i] = dRadius * cos(Lat[i] * PI / 180.) * sin(Lon[i] * PI / 180.);
        zarray[i] = dRadius * sin(Lat[i] * PI / 180.);
        debug5 << "QDF: (" << Lon[i] << ", " << Lat[i] << ") -> (" << xarray[i] << ", " << yarray[i] << ", " << zarray[i] << ")" << endl;
    }

 
    double* Dist = new double[nnodes*6];
    qdf_readArray(m_hGeoGroup, GEO_DS_DISTANCES, nnodes*6, Dist);
    for (int i = 0; i < nnodes*6; i++) {
        if (Dist[i] < m_fMinDistance && Dist[i] > 0) {
            m_fMinDistance = Dist[i];
        }
    }
    delete Dist;

    // FILL IN CONNECTIVITY

    // we don't know how many triangles we have,
    // so let's use a std::vector instead of a pre-alloc array
    std::vector<int> *connectivity = new std::vector<int>;
    
    // SCell members: ID NumNeigh Neigh[6]
    SCell* aCells = new SCell[nnodes];

    QDFReaderUtils::readCellData(m_hGridGroup, nnodes, aCells);
    
    // let's hope that this is not crazy

    int ntriangles = 0;
    for (int iC1 = 0; iC1 < nnodes; iC1++) {
        for (int i = 0; i < MAX_NEIGH; i++) {  

            int iC2 = aCells[iC1].m_aNeighbors[i];

            if (iC2 > iC1) {
                for (int j = 0; j < MAX_NEIGH; j++) {
                    
                    int iC3 = aCells[iC2].m_aNeighbors[j];

                    if (iC3 > iC2) {
                        for (int k = 0; k < MAX_NEIGH; k++) {
                            
                            if (aCells[iC3].m_aNeighbors[k] == iC1) {
                                
                                // woohoo, we found a triangle!
                                // now let's order the vertices counterclockwise
                                // the first will always be the one with lowest latitude
                                // but nodes 0 and 11 are "special" (in a bad way)

                                int ID1 = -1;
                                int ID2 = -1;
                                int ID3 = -1;

                                if (iC1 == 0) {

                                    ID1 = iC1;
                                    if (QDFPointsNorth(xarray[iC3], yarray[iC3],
                                                       xarray[iC2], yarray[iC2])) {
                                        ID2 = iC3;
                                        ID3 = iC2;
                                    } else {
                                        ID2 = iC2; 
                                        ID3 = iC3;
                                    }

                                } else if (iC1 == 11) {

                                    ID1 = iC1;
                                    if (QDFPointsNorth(xarray[iC2], yarray[iC2],
                                                       xarray[iC3], yarray[iC3])) {
                                        ID2 = iC3;
                                        ID3 = iC2;
                                        
                                    } else {
                                        ID2 = iC2;
                                        ID3 = iC3;
                                    }

                                } else if (iC2 == 11) {

                                    ID1 = iC2;
                                    if (QDFPointsNorth(xarray[iC1], yarray[iC1],
                                                       xarray[iC3], yarray[iC3])) {
                                        ID2 = iC3;
                                        ID3 = iC1;
                                    } else {
                                        ID2 = iC1;
                                        ID3 = iC3;
                                    }

                                } else if (iC3 == 11) {

                                    ID1 = iC3;
                                    if (QDFPointsNorth(xarray[iC1], yarray[iC1],
                                                       xarray[iC2], yarray[iC2])) {
                                        ID2 = iC2;
                                        ID3 = iC1;
                                    } else {
                                        ID2 = iC1;
                                        ID3 = iC2;
                                    }

                                } else {

                                    if (Lat[iC1] < Lat[iC2]) {
                                        if (Lat[iC1] < Lat[iC3]) {
                                            ID1 = iC1;
                                            if (QDFPointsNorth(xarray[iC3], yarray[iC3],
                                                               xarray[iC2], yarray[iC2])) {
                                                ID2 = iC2;
                                                ID3 = iC3;
                                            } else {
                                                ID2 = iC3;
                                                ID3 = iC2;
                                            }
                                        } else {
                                            ID1 = iC3;
                                            if (QDFPointsNorth(xarray[iC2], yarray[iC2],
                                                               xarray[iC1], yarray[iC1])) {
                                                ID2 = iC1;
                                                ID3 = iC2;
                                            } else {
                                                ID2 = iC2;
                                                ID3 = iC1;
                                            }
                                        }
                                    } else {
                                        if (Lat[iC2] < Lat[iC3]) {
                                            ID1 = iC2;
                                            if (QDFPointsNorth(xarray[iC3], yarray[iC3],
                                                               xarray[iC1], yarray[iC1])) {
                                                ID2 = iC1;
                                                ID3 = iC3;
                                            } else {
                                                ID2 = iC3;
                                                ID3 = iC1;
                                            }
                                        } else {
                                            ID1 = iC3;
                                            if (QDFPointsNorth(xarray[iC2], yarray[iC2],
                                                               xarray[iC1], yarray[iC1])) {
                                                ID2 = iC1;
                                                ID3 = iC2;
                                            } else {
                                                ID2 = iC2;
                                                ID3 = iC1;
                                            }
                                        }
                                    }
                                }

                                debug5 << "QDF: " << ID1 << " " << ID2 << " " << ID3 << endl;

                                connectivity->push_back(ID1);
                                connectivity->push_back(ID2);
                                connectivity->push_back(ID3);
                                ntriangles++;
                                k = MAX_NEIGH;
                            }
                        }
                    }
                }
            }
        }
    }

    delete[] Lat;
    delete[] Lon;
    delete[] aCells;

    debug1 << "QDF: Found " << ntriangles << " triangles" << endl;

    // CREATE VTK POINTS
    
    vtkPoints* Points = vtkPoints::New();
    
    Points->SetNumberOfPoints(nnodes);

    debug1 << "QDF: Setting coords for " << nnodes << " nodes" << endl;

    float *pts = (float *)Points->GetVoidPointer(0);
    for (int i = 0; i < nnodes; i++) {
            *pts++ = xarray[i];
            *pts++ = yarray[i];
            *pts++ = zarray[i];
            debug5 << "QDF: " << xarray[i] << " " << yarray[i] << " " << zarray[i] << endl;
    }
    
    delete[] xarray;
    delete[] yarray;
    delete[] zarray;
   
    
    // Create a vtkUnstructuredGrid to contain the points and cells
    
    vtkUnstructuredGrid *Grid = vtkUnstructuredGrid::New();
    Grid->SetPoints(Points);
    Points->Delete();
    Grid->Allocate(ntriangles);
    int nverts = 3;
    vtkIdType verts[nverts];

    for (int i = 0; i < ntriangles; i++) {

        for(int j = 0; j < nverts; j++) {
            verts[j] = (*connectivity)[3 * i + j];
        }

        Grid->InsertNextCell(VTK_TRIANGLE, nverts, verts);
    }
    
    delete connectivity;
    
    return Grid;
}


// ****************************************************************************
//  Method: avtQDFFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************

vtkDataArray *
avtQDFFileFormat::GetVar(const char *varname)
{
    vtkDataArray* Var = NULL;

    if (strcasecmp(varname, GEO_DS_ALTITUDE) == 0 ||
        strcasecmp(varname, GEO_DS_LONGITUDE) == 0 ||
        strcasecmp(varname, GEO_DS_LATITUDE) == 0 ||
        strcasecmp(varname, GEO_DS_AREA) == 0 ||
        strcasecmp(varname, GEO_DS_WATER) == 0 ||
        strcasecmp(varname, GEO_DS_ICE_COVER) == 0) {

        // geography variables
        if (m_hGeoGroup > 0) {
            Var = GetQDFScalar(m_hGeoGroup, varname);
        }

    } else if (strcasecmp(varname, CLI_DS_ACTUAL_TEMPS) == 0 ||
               strcasecmp(varname, CLI_DS_ACTUAL_RAINS) == 0 ||
               strcasecmp(varname, CLI_DS_ANN_MEAN_TEMP) == 0 ||
               strcasecmp(varname, CLI_DS_ANN_TOT_RAIN) == 0 ||
               strcasecmp(varname, CLI_DS_CUR_SEASON) == 0) {
        
        // climate variables
        if (m_hClimateGroup > 0) {
            Var = GetQDFScalar(m_hClimateGroup, varname);
        }
    } else if (strcasecmp(varname, "TravelledDist") == 0 ||
               strcasecmp(varname, "Hops") == 0 ||
               strcasecmp(varname, "Arrival") == 0 || 
               strcasecmp(varname, "LocalSpeed") == 0) {

        // move stats
        if (m_hMoveStatGroup > 0) {
            char realvarname[16];
            if (strcasecmp(varname, "TravelledDist") == 0) {
                sprintf(realvarname, "Dist");
            } else if (strcasecmp(varname, "Arrival") == 0) {
                sprintf(realvarname, "Time");
            } else if (strcasecmp(varname, "Hops") == 0) {
                sprintf(realvarname, "Hops");
            } else if (strcasecmp(varname, "LocalSpeed") == 0) {
                sprintf(realvarname, "LocalSpeed");
            }
            Var = GetQDFScalar(m_hMoveStatGroup, realvarname);
        }    
    } else {

        // vegetation or agent variables
        char *name = new char[128];
        strcpy(name,varname);
        char *subs = new char[128];
        subs = strtok(name, DUMMY_CHAR);

        if (strcmp(subs, VEG_DS_MASS) == 0 ||
            strcmp(subs, VEG_DS_NPP) == 0) {
            
            // vegetation variables
            Var = GetQDFVegScalar(varname);

        } else {

            subs = strtok(NULL, DUMMY_CHAR);
        
            if (strcmp(subs, NUMBER_NAME) == 0) {
                
                debug1 << "QDF: displaying " << varname << endl;
                // agent densities are "special"
                Var = GetQDFAgentNumber(varname);
                
            } else {
                
                // other agent scalars
                Var = GetQDFAgentScalar(varname);
            }
        }

        // don't delete or it crashes...
        // delete name;
        // delete subs;
    }

    return Var;
}

/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFScalar(hid_t hGroup, const char* varname) {

    int nnodes = -1;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    hid_t dataset = H5Dopen(hGroup, varname, H5P_DEFAULT); 
    hid_t datatype = H5Dget_type(dataset); 
    int ncheck = H5Dget_storage_size(dataset) / H5Tget_size(datatype);
    
    if (ncheck == nnodes) {
        hid_t native_type = H5Tget_native_type(datatype, H5T_DIR_DESCEND); 
        
        if (H5Tequal(H5T_NATIVE_DOUBLE, native_type)) {
            
            vtkDoubleArray* Scalar = vtkDoubleArray::New();
            Scalar->SetNumberOfTuples(nnodes);
            double* pData = (double *)Scalar->GetVoidPointer(0);
            
            qdf_readArray(hGroup, varname, nnodes, pData);
            
            
            return Scalar;
            
        } else if (H5Tequal(H5T_NATIVE_INT, native_type)) {

            vtkIntArray* Scalar = vtkIntArray::New();
            Scalar->SetNumberOfTuples(nnodes);
            int* pData = (int *)Scalar->GetVoidPointer(0);

            qdf_readArray(hGroup, varname, nnodes, pData);

            return Scalar;
        }
    }
}
        
/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFVegScalar(const char* varname) {

    int nnodes = -1;
    qdf_extractAttribute(m_hVegGroup, VEG_ATTR_NUM_CELLS, 1, &nnodes);
    
    char *name = new char[128];
    strcpy(name,varname);
    char *variable = new char[128];
    variable = strtok(name, DUMMY_CHAR);
    int vegtype = -1;
    vegtype = atoi(strtok(NULL, DUMMY_CHAR));
    
    double **pDummy = new double*[m_nVegSpecies];
    for (int i = 0; i < m_nVegSpecies; i++) {
        pDummy[i] = new double[nnodes];
    }
    qdf_readArrays(m_hVegGroup, variable, m_nVegSpecies, nnodes, pDummy);

    vtkDoubleArray* Scalar = vtkDoubleArray::New();
    Scalar->SetNumberOfTuples(nnodes);
    double* pData = (double*)Scalar->GetVoidPointer(0);
    
    for (int i = 0; i < nnodes; i++) {
        *pData++ = pDummy[vegtype][i];
    }
    
    

    return Scalar;
}




/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFAgentNumber(const char* varname) {

    int nnodes = -1;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    vtkIntArray* Scalar = vtkIntArray::New();
    Scalar->SetNumberOfTuples(nnodes);
    int* pData = (int *)Scalar->GetVoidPointer(0);
           
    for (int i = 0; i < nnodes; i++) {
        pData[i] = 0;
    }
        
    char* name = new char[128];
    strcpy(name, varname);
    char* popname = new char[64];
    popname = strtok(name, DUMMY_CHAR);
            
    debug1 << "QDF: getting number density for " << popname << endl;

    int nAgents = m_mapNAgents.find(popname)->second;
            
    char* sCellIDName = new char[128];
    strcpy(sCellIDName, popname);
    strcat(sCellIDName, DUMMY_CHAR);
    strcat(sCellIDName, GRID_DS_CELL_ID);

    std::map< std::string, std::pair<hid_t, hid_t> >::iterator it = m_mapAgentFields.find(sCellIDName);

    hid_t hPopData = (it->second).first;
    hid_t hCellIDType = (it->second).second;
            
    int *aiAgentCells = new int[nAgents];
            
    herr_t iErr = H5Dread(hPopData, hCellIDType, H5S_ALL, H5S_ALL, H5P_DEFAULT, aiAgentCells);
                
    if (iErr < 0) {
        debug1 << "QDF: could not read data" << endl;
    }
    else {

        debug1 << "QDF: data has been read, now filling in vtkIntArray for " << nnodes << " nodes" << endl;

        for (int i = 0; i < nAgents; i++) {
            int iCell = aiAgentCells[i];
            debug1 << "QDF: counted one agent in cell " << iCell << endl;
            if (iCell < nnodes) {
                pData[iCell] += 1;
            } else {
                debug1 << "QDF: crazy cell ID " << iCell << ", maximum is " << nnodes << endl;
            }
        }
    }

    delete aiAgentCells;

    // why does it crash if I delete these?
    // delete name;
    // delete popname;

    return Scalar;
}

/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFAgentScalar(const char* varname) {

    std::map< std::string, std::pair<hid_t, hid_t> >::iterator it = m_mapAgentFields.find(varname);
    hid_t hDataSet = (it->second).first;
    hid_t tCompoundFieldType = (it->second).second;
    // the data field type is a "fake" compound type that contains only one member...
    hid_t tFieldType = H5Tget_member_type(tCompoundFieldType, 0); 

    char* name = new char[128];
    strcpy(name, varname);
    char* popname = strtok(name, DUMMY_CHAR);

    int nAgents = (m_mapNAgents.find(popname))->second;

    debug1 << "QDF: get scalar " << varname << " for " << nAgents << " agents" << endl;
    
    hid_t native_type = H5Tget_native_type(tFieldType, H5T_DIR_DESCEND); 

    if (H5Tequal(H5T_NATIVE_DOUBLE, native_type)) {
        
        debug1 << "QDF: double scalar" << endl;

        vtkDoubleArray* Scalar = vtkDoubleArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        double* pData = (double *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
        return Scalar;

    } else if (H5Tequal(H5T_NATIVE_FLOAT, native_type)) {

        debug1 << "QDF: float scalar" << endl;

        vtkFloatArray* Scalar = vtkFloatArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        float* pData = (float *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
        return Scalar;
     
    } else if (H5Tequal(H5T_NATIVE_INT, native_type)) {

        debug1 << "QDF: int scalar" << endl;

        vtkIntArray* Scalar = vtkIntArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        int* pData = (int *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
        return Scalar;

    } else if (H5Tequal(H5T_NATIVE_LONG, native_type)) {

        debug1 << "QDF: long int scalar" << endl;

        vtkLongArray* Scalar = vtkLongArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        long int* pData = (long int *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
        return Scalar;
        
    } else if (H5Tequal(H5T_NATIVE_UCHAR, native_type)) {

        debug1 << "QDF: unsigned 8-bit scalar" << endl;

        vtkUnsignedCharArray* Scalar = vtkUnsignedCharArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        unsigned char* pData = (unsigned char *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
        return Scalar;
        
    }
}    


// ****************************************************************************
//  Method: avtQDFFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************

vtkDataArray *
avtQDFFileFormat::GetVectorVar(const char *varname)
{
    //    YOU MUST IMPLEMENT THIS
    return 0;

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}
